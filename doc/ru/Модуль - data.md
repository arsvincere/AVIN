# Модуль data

Простой интерфейс для работы с историческими данными:
- получение списка доступных активов (индексы, акции, облигации, фьючерсы,
    валюты, ETF)
- получение подробной информации об активе (ласт прайс, минимальный шаг цены,
    маржинальные коэффициенты и тп.)
- загрузка свечей от 1М до М
- импортирование данных в стандартный внутренний формат 
- преобразование таймфреймов
- обновление скачанных данных
- выдача списка файлов с данными по активу

Загрузка тиков и стаканов пока недоступна. В коде стоят ассерты.
Тестировалось только загрузка свеч по акциям и индексам Мос.Биржы. 

Если что, пишите: mr.alexavin@gmail.com


## Импорт
```python 
from avin.data import Source, DataType, Exchange, AssetType, Id, Data
```


## Краткое описание классов
Полные рабочие примеры смотри в "doc/examples/data"

### class Source <!--{{{-->
Перечисление доступных источников данных.

	UNDEFINE    = 0
	MOEX        = 1
	TINKOFF     = 2

Примеры:

    >>> Source.MOEX
    >>> Source.TINKOFF

<!--}}}-->
### class DataType <!--{{{-->
Перечисление доступных типов данных.

Мудреные value строки вместо int используются для облегчения построения путей
к файлам данных.

	BAR_1M      = "1M"
	BAR_5M      = "5M"
	BAR_10M     = "10M"
	BAR_1H      = "1H"
	BAR_D       = "D"
	BAR_W       = "W"
	BAR_M       = "M"
	BOOK        = "book"        # стаканы   
	TIC         = "tic"         # тики
	ANALYSE     = "analyse"     # пользовательский анализ .json

Примеры:

    >>> DataType.BAR_1M
    >>> DataType.BAR_D.name
    >>> DataType.BAR_D.value

<!--}}}-->
### class Exchange<!--{{{-->
Перечисление доступных бирж.

	UNDEFINE    = 0
	MOEX        = 1
	SPB         = 2

Примеры:

    >>> Exchange.MOEX
    >>> Exchange.MOEX.name
    >>> Exchange.MOEX.value

<!--}}}-->
### class AssetType<!--{{{-->
Перечисление типов активов 

	UNDEFINE    = 0
	Index       = 1
	Share       = 2
	Bond        = 3
	Future      = 4
	Currency    = 5
	Etf         = 6

Примеры:

    >>> AssetType.Share
    >>> AssetType.Future

<!--}}}-->
### class Id<!--{{{-->
Единый идентификатор для всех активов.

Содержит минимально достаточную информацию для однозначной идентификации 
инструмента. Именно этот тип используется во всех функциях работы с данными.

Ручное создание объектов класса утомительно. Модуль предоставляет функцию
для получения идентификатора через часть информации о нем, см. Data.find()

Инициализация:

    exchange (enum Exchange): биржа
    asset_type (enum AssetType): тип актива
    name (str): полное имя инструмента
    ticker (str): биржевой тикер
    figi (str): глобальный финансовый идентификатор, типо "BBG004S683W7"

Свойства:

    exchange (enum Exchange)
    type (enum AssetType)
    name (str)
    ticker (str)
    figi (str)
    dir_path (str): путь к папке с данными по активу

Методы:

    save(id_obj: Id, file_path: str) -> None
    load(file_path: str) -> Id
    
Примеры:

    >>> sber_id = Data.find(Exchange.MOEX, AssetType.Share, "SBER")
    >>> print(sber.name)
    >>> print(sber.figi)

<!--}}}-->
### class Data<!--{{{-->
Интерфейс для работы с данными.

Модуль кэширует информацию об инструментах один раз в сутки при первом 
запуске. Кэш находится в res/cache/<source>

Для полной функциональности модуля требуется:
1. Тинькофф токен.
Достаточно токена только для чтения. Без него не доступны никакие операции
с брокером. Где и как взять токен смотрите на официальном 
сайте: 
https://developer.tinkoff.ru/docs/intro/manuals/self-service-auth

Токен положить в файл usr/connect/tinkoff/token.txt

2. Аккаунт на Московской бирже.
Без него доступны только свечи с задержкой в 15 минут общая информация. После
регистрации доступны стаканы, и реал-тайм данные.
https://passport.moex.com/registration

Логин и пароль положить в файл usr/connect/moex/account.txt
Первая строка логин
Вторая строка пароль

Методы:
```python 

@classmethod
def assets(cls, source: Source, asset_type: AssetType) -> list[Id]: ... 
    Получение полного списка активов от источника

@classmethod
def find(cls, exchange: Exchange, asset_type: AssetType, querry: str) -> Id: ...
    Возвращает стандартный идентификатор. Аргумент querry - строка с 
    тикером, figi, или tinkoff uid

@classmethod
def info(cls, ID: Id) -> dict: ...
    Полная информация об инструменте: размер лота, дата экспирации (если 
    это фьючерс) и тп.

@classmethod
def download(cls, source: Source, data_type: DataType, ID: Id, year: int) -> bool: ...
    Загружает данные 'как есть' у источника, по умолчанию в папку 
    'usr/download'.
    Если нужно вынести данные в другую директорию отредактируйте
    файл 'avin/const.py', переменная Usr.DOWNLOAD.
    Можно указать абсолютный путь вместо относительного.

@classmethod
add(cls, source: Source): ...
    Импортирует данные загруженные из источника 'source' в систему в
    стандартном внутреннем формате.
    Если в папке Usr.DOWNLOAD ничего нет, ничего не делает.
    Если нужно вынести данные в другую директорию отредактируйте
    файл 'avin/const.py', переменная Usr.DATA.
    Можно указать абсолютный путь вместо относительного.

@classmethod
convert(cls, ID: Id, in_type: DataType, out_type: DataType) -> bool: ...
    Преобразует таймфреймы. Данные должны быть предварительно загружены и
    добавлены в систему.

@classmethod
clear(cls, source: Source) -> bool: ...
    Удаляет папку с загруженными исходными данными, usr/download/<source>

@classmethod
delete(cls, ID: Id, data_type: DataType) -> bool: ...
    Удаляет данные из системы

@classmethod
update(cls, ID: Id, daya_type: DataType):
    Проверяет наличие новых свечей для актива.
    Данные по активу должны быть предварительно загружены и добавлены
    в систему. Функция загружает только новые исторические бары,
    незавершенные бары для таймфреймов D, W, M игнорируются.
    На младших таймфреймах MOEX задержка до 15 минут. При наличии аккаунта
    1-2 минуты. С Тинькофф данные идут с задержкой от 10сек до 2мин.

@classmethod
updateAll(cls):
    Собирает список всех имеющихся в системе активов и типов данных затем
    вызывает для них функцию update()

@classmethod
request(cls, ID: Id, data_type: DataType, begin: int, end: int) -> list[file_path]:
    Находит данные за период [begin_year, end_year], возвращает список путей
    к файлам .csv 
    Это сделано для большей гибкости. Таким образом вызывающая сторона 
    сама решает как читать файлы, загрузить целиком как строки, читать
    построчно через итератор, или загрузить в DataFrame.

```
<!--}}}-->

